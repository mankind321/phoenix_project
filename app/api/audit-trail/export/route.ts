/* eslint-disable @typescript-eslint/no-explicit-any */

import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";
import PDFDocument from "pdfkit";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { PassThrough } from "stream";
import fs from "fs";
import path from "path";

/* ============================================================
   üîê HEADER-BASED RLS CLIENT (service role + headers)
============================================================ */
function createRlsClient(headers: Record<string, string>) {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!, // ‚¨Ö REQUIRED for header-based RLS
    {
      db: { schema: "public" },
      global: { headers },
    }
  );
}

export async function GET(req: Request) {
  try {
    /* -------------------------------------------------------
       1Ô∏è‚É£ Validate session
    -------------------------------------------------------- */
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { success: false, message: "Unauthorized" },
        { status: 401 }
      );
    }

    /* -------------------------------------------------------
       2Ô∏è‚É£ Build RLS headers
    -------------------------------------------------------- */
    const rlsHeaders = {
      "x-app-role": session.user.role,
      "x-user-id": session.user.id,
      "x-account-id": session.user.accountId ?? "",
    };

    /* -------------------------------------------------------
       3Ô∏è‚É£ Create RLS Supabase client
    -------------------------------------------------------- */
    const supabase = createRlsClient(rlsHeaders);

    /* -------------------------------------------------------
       4Ô∏è‚É£ Extract filters
    -------------------------------------------------------- */
    const url = new URL(req.url);
    const action = url.searchParams.get("action") || "all";
    const search = url.searchParams.get("search") || "";
    const fromDate = url.searchParams.get("fromDate");
    const toDate = url.searchParams.get("toDate");

    /* -------------------------------------------------------
       5Ô∏è‚É£ Base query ‚Üí RLS ENFORCED
    -------------------------------------------------------- */
    let query = supabase
      .from("system_audit_trail")
      .select("*")
      .order("created_at", { ascending: false });

    // üéØ Action Filter
    if (action !== "all") {
      query = query.eq("action_type", action.toUpperCase());
    }

    // üîç Search filter
    if (search) {
      query = query.or(
        [
          `username.ilike.%${search}%`,
          `role.ilike.%${search}%`,
          `description.ilike.%${search}%`,
          `table_name.ilike.%${search}%`,
        ].join(",")
      );
    }

    // üìÖ Date filters
    if (fromDate) query = query.gte("created_at", fromDate);
    if (toDate) query = query.lte("created_at", `${toDate} 23:59:59`);

    /* -------------------------------------------------------
       6Ô∏è‚É£ Execute query
    -------------------------------------------------------- */
    const { data: logs, error } = await query;
    if (error) throw error;

    /* -------------------------------------------------------
       7Ô∏è‚É£ Load PDF fonts
    -------------------------------------------------------- */
    const fontRegular = fs.readFileSync(
      path.join(process.cwd(), "public/fonts/Roboto-Regular.ttf")
    );
    const fontBold = fs.readFileSync(
      path.join(process.cwd(), "public/fonts/Roboto-Bold.ttf")
    );

    /* -------------------------------------------------------
       8Ô∏è‚É£ Setup PDF stream
    -------------------------------------------------------- */
    const stream = new PassThrough();
    const doc = new PDFDocument({
      size: "Legal",
      margins: { top: 30, left: 50, right: 40, bottom: 30 },
      bufferPages: true,
    });
    doc.pipe(stream);

    const webStream = new ReadableStream({
      start(controller) {
        stream.on("data", (chunk) => controller.enqueue(chunk));
        stream.on("end", () => controller.close());
        stream.on("error", (err) => controller.error(err));
      },
    });

    doc.registerFont("Regular", fontRegular);
    doc.registerFont("Bold", fontBold);
    doc.font("Regular");

    /* -------------------------------------------------------
       9Ô∏è‚É£ Header
    -------------------------------------------------------- */

    doc.moveDown(3);
    doc.font("Bold").fontSize(16).text("Phoenix Project Real Property Document Management", 50);
    doc.font("Regular")
      .fontSize(11)
      .text("System Audit Trail Report", 50)
      .moveDown(1);
    doc.text(`Generated by: ${session.user.username}`, 50);
    doc.text(`Date Generated: ${new Date().toLocaleString()}`, 50).moveDown(1.5);

    /* -------------------------------------------------------
       üîü Summary counts
    -------------------------------------------------------- */
    const summary = {
      VIEW: logs.filter((l) => l.action_type === "VIEW").length,
      CREATE: logs.filter((l) => l.action_type === "CREATE").length,
      UPDATE: logs.filter((l) => l.action_type === "UPDATE").length,
      DELETE: logs.filter((l) => l.action_type === "DELETE").length,
    };

    doc.font("Bold").fontSize(12).text("Activity Summary:", 50);
    doc.font("Regular").fontSize(10);

    Object.entries(summary).forEach(([type, count]) =>
      doc.text(`${type}: ${count}`, 62)
    );
    doc.moveDown(1);

    /* -------------------------------------------------------
       üîΩ Table Header Draw Helper
    -------------------------------------------------------- */
    const headers = ["Action", "User", "Table", "Record ID", "Timestamp"];
    const widths = [200, 50, 120, 70, 110];

    const drawTableHeader = () => {
      const startX = 50;
      const startY = doc.y;

      doc.font("Bold").fontSize(10);
      headers.forEach((h, i) => {
        const colX = startX + widths.slice(0, i).reduce((a, b) => a + b, 0);
        doc.text(h, colX, startY, { width: widths[i], align: "left" });
      });

      doc.moveTo(startX, startY + 12)
        .lineTo(startX + widths.reduce((a, b) => a + b, 0), startY + 12)
        .stroke();

      doc.moveDown(1);
    };

    drawTableHeader();

    /* -------------------------------------------------------
      üîΩ Table Rows (with WRAP + proper overflow check)
    -------------------------------------------------------- */
    logs.forEach((log, idx) => {
      const row = [
        log.action_type,
        log.username,
        log.table_name,
        log.record_id || "-",
        new Date(log.created_at).toLocaleString(),
      ];

      // Calculate row height BEFORE drawing (fix)
      let tempMaxHeight = 0;
      row.forEach((txt, i) => {
        const h = doc.heightOfString(txt, { width: widths[i] });
        if (h > tempMaxHeight) tempMaxHeight = h;
      });

      // If row would overflow ‚Üí add page BEFORE rendering
      if (doc.y + tempMaxHeight + 10 > doc.page.height - 60) {
        doc.addPage();
        drawTableHeader();
      }

      const yPos = doc.y;

      // Zebra stripe
      if (idx % 2 === 0) {
        doc.save();
        doc.rect(50, yPos - 2, 530, tempMaxHeight + 4)
          .fillColor("#f2f2f2")
          .fill();
        doc.restore();
      }

      // Draw row text
      doc.font("Regular").fontSize(8).fillColor("#000");

      row.forEach((txt, i) => {
        const x = 50 + widths.slice(0, i).reduce((a, b) => a + b, 0);
        doc.text(txt, x, yPos, {
          width: widths[i],
          align: "left",
        });
      });

      // Move pointer down by computed row height
      doc.y = yPos + tempMaxHeight + 6;
    });


    /* -------------------------------------------------------
    üìÑ Page Number Footer (FIXED)
    -------------------------------------------------------- */
    const pageCount = doc.bufferedPageRange().count;

    for (let i = 0; i < pageCount; i++) {
      doc.switchToPage(i);

      const footerY = doc.page.height - doc.page.margins.bottom - 30;

      doc.fontSize(9).text(
        `Page ${i + 1} of ${pageCount}`,
        50,
        footerY,
        {
          width: doc.page.width - 100,
          align: "center",
        }
      );
    }

    doc.end();   // <-- REQUIRED (You removed this earlier)


    /* -------------------------------------------------------
       üì§ Return PDF stream
    -------------------------------------------------------- */
    return new Response(webStream, {
      status: 200,
      headers: {
        "Content-Type": "application/pdf",
        "Content-Disposition": "attachment; filename=audit-trail.pdf",
      },
    });
  } catch (err: any) {
    console.error("‚ùå PDF Export Error:", err);
    return NextResponse.json(
      { success: false, message: err.message },
      { status: 500 }
    );
  }
}
